#!/usr/bin/python
#coding = UTF-8

__author__ = 'Benjamin Rice, benjaminrice01@gmail.com'

"""
                            fileSystemModeller.py
    ====================================================================
    The following python script is designed to work in conjunction with
    the Encase 'Text Extractor.EnScript' script developed for the popular
    forensics program 'EnCase Forensic v7.10.05'.

    Although this script does not rely on EnCase to function, it parses
    files in a particular format generated by the above EnScript. As such,
    it is possible to use independently if files are generated in the same
    fashion. The python script parses text files from the same directory
    with two attributes designated in each text file, separated by newline:
        'full file path' - ie C/Users/Administrator/Desktop
        'file category' - at a minimum, must have 'file' or 'folder'

    Both this script and the above EnScript were developed for the
    dissertation:

    'Triage in digital forensics by targeting file system structures'
    Benjamin Rice
    Bachelor of Information Technology (Hons) (Cyber Security)
    Australian Centre for Cyber Security
    University of New South Wales - Canberra


    The author can be contacted at benjaminrice01@gmail.com

    ====================================================================

    The program has two main functions: one to parse in the text files
    and create a list representing the inputted data and another to
    generate a file system model of the provided data. The main function
    allows the user to specify input and output paths as well as a few
    other variables. The following comment blocks will describe the
    use of this function chronologically

                        main function
    ----------------------------------------------------------------
    The main function asks the user for the location where
    the text files are stored. The user then inputs the full path
    location of the text files. The user is also asked to input
    the root file name. This part is not ideal and may require
    some modification post model creation - if the root is
    repeated multiple times in the path name, then there is
    the possibility for the 'wrong' root file to be selected.
    This is not a major problem - the analyst or investigator just
    needs to have some awareness of the selected file system from
    the EnCase investigation.

                    function 1: fileExtractor
    ----------------------------------------------------------------
    fileExtractor takes the location and file root from the user
    and processes the text files into a list. As EnCase exports
    file text in an awkward encoding, the function will convert
    the text within the file to 'utf-16-le' format so the text
    is correctly displayed within the list. Note that UTF-8 was
    used as standard when developing these scripts, but UTF-16-le
    is needed to correctly interpret the EnCase written files.
    This function then takes every file and stores the file path
    and file category (file or folder, at a minimum) into a list.
    A bit of text manipulation is required to get it into the
    required format, and for this proof-of-concept model, error
    catching was added to get around the Windows 7 restriction
    on extremely long file names. As an aside, some of the file
    names generated by EnCase are extremely long. This is due to
    adding a globally unique identifier to each file so that
    duplicate named files on large file systems do not get lost
    or overwritten when exported.

                        main function
    ----------------------------------------------------------------
    After the list has been generated, the user is then asked
    for two more input items. The first is the full location
    for the list to generate the model at. The second asks the
    user to associate the generated model with a type of crime.

                     function 2: fsModeller
    ----------------------------------------------------------------
    fsModeller (filesystem Modeller) takes the list and generates
    a model representing that list at the chosen export location.
    Firstly, it does a bit of user input validation - if the user
    did not end the path with a trailing backslash, the program
    will add this onto the path to avoid model generation at an
    incorrect location. At the location of the model generation,
    if a folder does not exist for that type of crime, the program
    will generate that crime folder and store the model within.
    This function has two major loops:
        the first loop generates all folders of the model
        the second loop populates all folders with files
    All files generated represent the original file on the actual
    case's file system, however, they will have no substance other
    than the original file name. If the file name maintains a
    certain extension type, the file will maintain the icon and
    file type for that extension, but maintaining none of the data
    within.
    The first loop is quite simple - if the full path of the list
    entry doesn't exist and the category is for a folder, it will
    generate that folder and any parent folders requried that don't
    exist.
    The second loop checks that the parent folder of the location
    where that file should reside exists and then generates a file
    at the location inside that folder. If this check did not occur,
    the program would try and find a folder with a path the exact
    same as the file - which would cause an incorrect location
    for the file. Error catching also occurs here for the long path
    name error mentioned earlier.
    ----------------------------------------------------------------

    References:
    Apart from many random threads on stack overflow, for the idea
    and development (especially for the initial EnScript asssistance!)
    special thanks goes to:
    James Habben: Master Instructor, Guidance Software
    Chet Hosmer: author of Python Forensics
                and webmaster of python-forensics.org
    Link:
    http://encase-forensic-blog.guidancesoftware.com/2015/06/enscript
        -and-python-exporting-many.html

"""

import os
import codecs

#the path of text documents exported from Encase - defined in EnScript
FILE_INPUT_PATH = ''
#the path for the model to be generated at
MODEL_OUTPUT_PATH = ''
#a list containing all text from all text documents from Encase
fslist = []

# function that extracts all attributes defined in the FILE_INPUT_PATH text documents
# these attributes are then stored in a list from which the model will be built
def fileExtractor(FILE_INPUT_PATH,fsroot):

    print ('Processing text files...please wait.')

    global fslist
    count = 0

    #user validation
    fsroot = "\\" + fsroot + "\\"

    #for each file in the directory indicated by FILE_INPUT_PATH
    for file in os.listdir(FILE_INPUT_PATH):

        try:
        #puts Encase exported data in required format for processing
            f = codecs.open(os.path.join(FILE_INPUT_PATH, file), "rb", encoding='utf-16-le')

        #unique file names reduce collision errors, but increase OS specific length issues
        #for proof-of-concept, Windows allows longer path names if you prepend '\\?\'
        except IOError:
            LONG_INPUT_PATH = "\\\\?\\" + FILE_INPUT_PATH
            f = codecs.open(os.path.join(LONG_INPUT_PATH, file), "rb", encoding='utf-16-le')

        #read all text in the file, and split into two strings by the Windows delimiter
        #Encase exports files with attributes split by Windows delimiter
        s1 = f.read()
        s1, s2 = s1.rsplit('\r\n')
        #remove redundant Encase case-generated path
        s1 = s1.partition(fsroot)[-1]
        #Add the specified user root to the file path
        s1 = fsroot + s1

        fslist.append(s1)
        fslist.append(s2)
        f.close()

        count = count + 1

    print 'Processing Complete'
    print count,'files have been processed\n'

def fsModeller (MODEL_OUTPUT_PATH,crime):

    #set the counters to iterate through the list
    cpath = 0
    ctype = 1

    #appends to filenames so duplicate files do not overwrite each other
    dup = 0
    listmax = len(fslist)

    #validate user input
    if MODEL_OUTPUT_PATH.endswith("\\") is False:
        MODEL_OUTPUT_PATH = MODEL_OUTPUT_PATH + "\\"

    #append the folder for crime type to the output path
    MODEL_OUTPUT_PATH = MODEL_OUTPUT_PATH + crime

    #if a folder hasn't been created for that crime type, make it
    if os.path.exists(MODEL_OUTPUT_PATH) is False:
            os.mkdir(MODEL_OUTPUT_PATH)

    #this for loop generates the folders
    for x in xrange (0,listmax/2):

        #combines the local system location, and the model hierarchy build location
        fslist[cpath] = fslist[cpath].lstrip('\\')
        FULL_PATH = os.path.join(MODEL_OUTPUT_PATH, fslist[cpath])

        #if the folder path doesn't exist and the list element is a folder
        if os.path.exists(FULL_PATH) is False and "Folder" in fslist[ctype]:
            #make directory at location, and all parent directories required for that path
            os.makedirs(FULL_PATH)

        #as path/file category are stored in this fashion in the list
        cpath = cpath + 2
        ctype = ctype + 2

    print '\n Folders Created.'

    #refresh counters
    cpath = 0
    ctype = 1

    #this for loop generates the files
    for x in xrange (0,listmax/2):

        #again, takes the path designated from the text file and adds local system location
        FULL_PATH = os.path.join(MODEL_OUTPUT_PATH, fslist[cpath])

        #if the immediate parent of the list element exists and the element is a file
        if os.path.exists(("\\".join(FULL_PATH.split("\\")[:-1]))) is True and "File" in fslist[ctype]:
                try:
                    #generate a file at the specified location)
                    if os.path.exists(FULL_PATH) is False:
                        open(FULL_PATH,'a').close()
                    else:
                        #ensure duplicate named files do not overwrite
                        open((os.path.join(FULL_PATH + str(dup))),'a').close()
                        dup += 1
                except IOError:
                    LONG_PATH = "\\\\?\\" + FULL_PATH
                    if os.path.exists(LONG_PATH) is False:
                        open(LONG_PATH,'a').close()
                    else:
                        open((os.path.join(LONG_PATH + str(dup))),'a').close()
                        dup += 1

        #looping of the list elements for the second for loop
        cpath = cpath + 2
        ctype = ctype + 2

    print '\n Files Created.'

def main():

    print ("Hello - welcome to Ben's File Model Builder.")

    d = raw_input ("Enter the local file system directory location to process text files from. \n"
                   "For example - C:\Users\George\ForensicOutput\TextFiles \n"
                    " : ")
    opt = raw_input("\n What is the expected root file name? \n "
                    " For user space, this is most likely the account name. \n"
                    " For example: 'George','z1234567','Administrator'. \n"
                    " : ")
    fileExtractor(d,opt)

    print ("Now onto the next part!\n")

    d2 = raw_input ("Enter the location for the file system model to be generated at. \n"
                    "As long as the full file path is entered, this can be local or external. \n"
                    "For example - C:\Users\George\FileSysModels \n"
                    " : ")
    opt2 = raw_input ("What is the crime this user was most associated with? "
                           " : ")
    fsModeller(d2,opt2)

    print ("\nModel has been generated! Thanks for using the File Model Builder!")

if __name__ =="__main__":
    main()


'''
    #Replace main function with the below to conduct time efficiency tests
---------------------------------------------------------------------------------
    print "Running time = "
    print time.clock()-start_time, "seconds \n"

    fileExtractor(FILE_INPUT_PATH,FILE_ROOT)
    fsModeller(MODEL_OUTPUT_PATH,CRIME_TYPE)

    print "Running time = "
    print time.clock()-start_time, "seconds \n"

    print ("\nModel has been generated! Thanks for using the File Model Builder!")
-----------------------------------------------------------------------------------
    #Add following variables to top of program, and define own INPUT/OUTPUT paths
    #FILE_ROOT = ''
    #CRIME_TYPE = ''
    #import time
    #start_time = time.clock()
'''